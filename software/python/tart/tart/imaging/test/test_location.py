from tart.imaging import location
from tart.imaging import sun
from tart.util import angle
from tart.imaging import tart_util

from tart.util import utc

import datetime
import numpy as np
import unittest

Dunedin = location.Dunedin
Aachen = location.Aachen

class TestLocation(unittest.TestCase):
    #http://www.heavens-above.com/whattime.aspx?lat=-45.86391200&lng=170.51348452&loc=TART&alt=46.5&tz=NZST            
    def setUp(self):
        self.utc_date = utc.utc_datetime(year=2009, month=7, day=22, hour=5, minute=9, second=50.3)
 
    '''
    http://www.ngs.noaa.gov/cgi-bin/xyz_getxyz.prl
    =============================================================
                        Latitude                     Longitude            Ellip_Ht     Ellipsoid
    INPUT =     S455150.0832             E1703048.54427 46.5             GRS80        
    =============================================================


        X (Meters)        Y (Meters)        Z (Meters)        ELLIPSOID
        ------------- ------------- ------------- ---------

        -4388375.1765     733300.4705 -4554760.4738 GRS80
    '''
    def test_ecef(self):
        x,y,z = Dunedin.get_ecef()
        self.assertAlmostEqual(x, -4388375.1765, 3) 
        self.assertAlmostEqual(y, 733300.4705, 3) 
        self.assertAlmostEqual(z, -4554760.4738, 3) 
    
    def test_XYX(self):
        x,y,z = Dunedin.get_XYZ(0., 0., 0.)
        self.assertAlmostEqual(x, 0.) 
        self.assertAlmostEqual(y, 0.) 
        self.assertAlmostEqual(z, 0.) 
        x,y,z = Dunedin.get_XYZ(0., 10., 0.) # 100m north
        print x, y, z
        dx,dy,dz = Dunedin.get_ecef_delta_from_enu(0., 10., 0.)
        print dx, dy, dz
        self.assertAlmostEqual(x, dx, 1) 
        self.assertAlmostEqual(y, dy, 1) 
        self.assertAlmostEqual(z, dz, 1) 
        
    ''' 
    The test vectors for this are generated by 
    http://xjubier.free.fr/en/site_pages/astronomy/coordinatesConverter.html
    '''

    def test_get_ecef_delta_from_enu(self):
        #print 'Testing ECEF2ENU2ECEF'
        x,y,z = Dunedin.get_ecef()
        e,n,u = Dunedin.ecef_to_enu(x,y,z)
        x2,y2,z2 = Dunedin.get_ecef_delta_from_enu(e,n,u)
        self.assertAlmostEqual(x, x2, 3) 
        self.assertAlmostEqual(y, y2, 3) 
        self.assertAlmostEqual(z, z2, 3)


    def test_horizontal_to_equatorial(self):
        #el_t = angle.from_dms(90.)
        #az_t = angle.from_dms(0.0)
        #ra, decl = Dunedin.horizontal_to_equatorial(self.utc_date, el_t, az_t)
        #st = Dunedin.LST(self.utc_date)
        #self.assertAlmostEqual(st.to_degrees(), ra.to_degrees(), 5)


        import ephem
        dnd = ephem.Observer()
        dnd.lon = str(Dunedin.lon.to_degrees())
        dnd.lat = str(Dunedin.lat.to_degrees())
        dnd.elevation = Dunedin.alt
        dnd.pressure = 0.0
        dnd.date = self.utc_date


        for az in np.arange(0, 360, 10):
            for el in np.arange(-90, 90, 5):
                az_i = angle.from_dms(az)
                el_i = angle.from_dms(el)

                ra, dec = Dunedin.horizontal_to_equatorial(self.utc_date, el_i, az_i)
                el_f, az_f = Dunedin.equatorial_to_horizontal(self.utc_date, ra, dec)
                
                #print Dunedin
                #print 'INIT: el az:', el_i, az_i
                #print 'RA, DEC', ra, dec
                #print 'FINAL: el az:', el_f, az_f

                self.assertTrue((el_i - el_f) < angle.from_dms(0.01))
                if (abs(el) != 90):
                    self.assertTrue((az_i - az_f) < angle.from_dms(0.01))

    
    def test_equatorial_to_horizontal_dunedin(self):

        # http://www.ccdimages.com/Planets.aspx
        # get RA,dec for planets 
        # verify RA and dec with ephem                                                [OK]
        # get el and az with ephem for dunedin today
        # calc el and az from RA and dec with OUR function

        import ephem
        dnd = ephem.Observer()
        dnd.lon = str(Dunedin.lon.to_degrees())
        dnd.lat = str(Dunedin.lat.to_degrees())
        dnd.elevation = Dunedin.alt
        dnd.pressure = 0.0
        datee = datetime.datetime.utcnow()
        dnd.date = datee

        objectlist = [ephem.Sun(),ephem.Mercury(),ephem.Venus(),ephem.Mars(),ephem.Jupiter(),ephem.Saturn(),ephem.Uranus(),ephem.Neptune()]
        for j in objectlist:
            j.compute(dnd)
            ra = angle.from_rad(j.ra.real)
            dec= angle.from_rad(j.dec.real)
            el, az = Dunedin.equatorial_to_horizontal(datee, ra, dec)
            self.assertAlmostEqual(el.to_rad(),j.alt.real,3) 
            self.assertAlmostEqual(az.to_rad(),j.az.real,3) 

    def test_equatorial_to_horizontal_aachen(self):

        # http://www.ccdimages.com/Planets.aspx
        # get RA,dec for planets 
        # verify RA and dec with ephem                                                [OK]
        # get el and az with ephem for dunedin today
        # calc el and az from RA and dec with OUR function

        import ephem
        dnd = ephem.Observer()
        dnd.lon = str(Aachen.lon.to_degrees())
        dnd.lat = str(Aachen.lat.to_degrees())
        dnd.elevation = Aachen.alt
        dnd.pressure = 0.0
        datee = datetime.datetime.utcnow()

        dnd.date = datee
        #print dnd.date

        objectlist = [ephem.Sun(),ephem.Mercury(),ephem.Venus(),ephem.Mars(),ephem.Jupiter(),ephem.Saturn(),ephem.Uranus(),ephem.Neptune()]
        for j in objectlist:
            j.compute(dnd)
            ra = angle.from_rad(j.ra.real)
            dec= angle.from_rad(j.dec.real)
            el, az = Aachen.equatorial_to_horizontal(datee, ra, dec)
            self.assertAlmostEqual(el.to_rad(),j.alt.real,3) 
            self.assertAlmostEqual(az.to_rad(),j.az.real,3) 

    ''' the Right Ascension of the Zenith: it is exactly the same as your Local Sidereal Time. '''

    def test_LST(self):
        st = Dunedin.LST(self.utc_date)
        check = angle.from_hours(12.53767)
        self.assertAlmostEqual(st.to_degrees(), check.to_degrees(),    2)
        
        utc_datetime = datetime.datetime(2013,9,12,9,10,0)
        
        LST = Dunedin.LST(utc_datetime).to_hours()%24

        lst_h = int(LST)
        lst_m = int((LST-int(LST))*60.)
        lst_s = int(((LST-int(LST))*60-int((LST-int(LST))*60))*60)

        self.assertAlmostEqual(lst_h, 19,    2)
        self.assertAlmostEqual(lst_m, 58,    2)
        self.assertAlmostEqual(lst_s, 13,    2)


    def test_GST(self):
        utc_datetime = datetime.datetime(2013,9,12,9,10,0)
        GST = Dunedin.GST(utc_datetime).to_hours()%24
        gst_h = int(GST)
        gst_m = int((GST-int(GST))*60.)
        gst_s = int(((GST-int(GST))*60-int((GST-int(GST))*60))*60)

        self.assertAlmostEqual(gst_h, 8,    2)
        self.assertAlmostEqual(gst_m,36,    2)
        self.assertAlmostEqual(gst_s, 9,    2)

    def test_julian_date(self):
        jd    = tart_util.JulianDay(self.utc_date)
        self.assertAlmostEqual(jd, 2455034.71516, 5)
    
    def test_solar_elevation(self):
        t = utc.now()
        s = sun.Sun()
        ra, decl = s.radec(t)

        el, az = Dunedin.equatorial_to_horizontal(t, ra, decl)
        el1, az1 = s.to_horizontal(Dunedin, t)
        self.assertAlmostEqual(el.to_degrees(), el1.to_degrees(), 5)
        self.assertAlmostEqual(az.to_degrees(), az1.to_degrees(), 5)

        
    def test_eci_to_ecef(self):
        utc_date = utc.now()
        x_in = 12345e3
        y_in = 23456e3
        z_in = 12345e3

        ecef = location.eci_to_ecef(utc_date, x_in, y_in, z_in)

        x,y,z = location.ecef_to_eci(utc_date, ecef[0], ecef[1], ecef[2])
        self.assertAlmostEqual(x_in, x)
        self.assertAlmostEqual(y_in, y)
        self.assertAlmostEqual(z_in, z)


    def test_horizontal_to_ecef(self):
        theta = 90.0  # Straight Up
        phi = 0.0

        x,y,z = Dunedin.horizontal_to_ecef(0.0, angle.from_dms(theta), angle.from_dms(phi))
        
        ecef = Dunedin.get_ecef()
        
        self.assertAlmostEqual(x, ecef[0])
        self.assertAlmostEqual(y, ecef[1])
        self.assertAlmostEqual(z, ecef[2])

    def test_horizontal_to_ecef_and_back(self):
        theta = np.random.rand(100)*np.pi/2
        phi = np.random.rand(100)*np.pi*2
        r = 100.0
        for i in range(100):
            x,y,z = Dunedin.horizontal_to_ecef(r, angle.from_rad(theta[i]), angle.from_rad(phi[i]))

            r2, theta2, phi2 = Dunedin.ecef_to_horizontal(x,y,z)

            self.assertAlmostEqual(theta2.to_rad(), theta[i])
            self.assertAlmostEqual(phi2.to_rad(), phi[i])
